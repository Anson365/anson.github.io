[{"title":"第一次马拉松","url":"http://anson666.top/2017/08/19/first-marathon/","content":"<p>  2017年8月19日，一路的舟车劳顿，来到了美丽的鄂尔多斯，<br>  迎来了人生第一个半程马拉松。。。  </p>\n<p>  虽然之前有过线下马拉松的经历，但是鄂尔多斯的高原环境，加上紧张激烈的比赛<br>  氛围，使本次马拉松的难度变得异常艰辛。  </p>\n<p>  15公里之后，开始喘着粗气，原本轻盈的步伐也变得无比的沉重。小腿也变得<br>  无比的酸疼，跑步的汗水，伴随着草原的冷风迅速蒸发，全身开始发冷。<br>  后面的队友开始渐渐超过我。。。  </p>\n<p>  我知道我的极限快到了，但是我不能放弃！<br>  我的首次马拉松，不能半途而废！<br>  我的每次迈步，都将是我人生的新的高度！<br>  坚持下去，冲过终点的那一瞬间，我肯定会感激现在不曾放弃的我！  </p>\n<p>  终于20公里！800米倒计时，400米，终点！<br>  1：56：51 顺利完赛！<br>  开始，加油！<br>  <img src=\"http://oxg1ehxo9.bkt.clouddn.com/WechatIMG36.jpeg?imageMogr2/auto-orient/thumbnail/500x/format/jpg/blur/1x0/quality/100|imageslim\" alt=\"起点\"><br>  <img src=\"http://oxg1ehxo9.bkt.clouddn.com/WechatIMG38.jpeg?imageMogr2/auto-orient/thumbnail/500x/format/jpg/blur/1x0/quality/100|imageslim\" alt=\"大桥\"><br>  <img src=\"http://oxg1ehxo9.bkt.clouddn.com/WechatIMG37.jpeg?imageMogr2/auto-orient/thumbnail/500x/format/jpg/blur/1x0/quality/100|imageslim\" alt=\"大桥\"><br>  <img src=\"http://oxg1ehxo9.bkt.clouddn.com/WechatIMG39.jpeg?imageMogr2/auto-orient/thumbnail/500x/format/jpg/blur/1x0/quality/100|imageslim\" alt=\"完赛奖牌\">  </p>\n","categories":["life"],"tags":["马拉松"]},{"title":"kafka常用指令集","url":"http://anson666.top/2017/08/14/kafka-command-line/","content":"<p>  在学习kafka的过程中，经常会用到一些console命令行。现在对这些命令行进行一个简单的汇总，方便今后查阅。  </p>\n<h3 id=\"启动zookeeper\"><a href=\"#启动zookeeper\" class=\"headerlink\" title=\"启动zookeeper\"></a>启动zookeeper</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bin/zookeeper-server-start.sh config/zookeeper.properties</div></pre></td></tr></table></figure>\n<h3 id=\"启动broker\"><a href=\"#启动broker\" class=\"headerlink\" title=\"启动broker\"></a>启动broker</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bin/kafka-server-start.sh config/server.properties</div></pre></td></tr></table></figure>\n<h3 id=\"创建TOPIC\"><a href=\"#创建TOPIC\" class=\"headerlink\" title=\"创建TOPIC\"></a>创建TOPIC</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</div></pre></td></tr></table></figure>\n<h3 id=\"查看topic-list\"><a href=\"#查看topic-list\" class=\"headerlink\" title=\"查看topic list\"></a>查看topic list</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bin/kafka-topics.sh --list --zookeeper localhost:2181</div></pre></td></tr></table></figure>\n<h3 id=\"console-producer\"><a href=\"#console-producer\" class=\"headerlink\" title=\"console producer\"></a>console producer</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</div></pre></td></tr></table></figure>\n<h3 id=\"console-producer-with-output-info\"><a href=\"#console-producer-with-output-info\" class=\"headerlink\" title=\"console producer with output info\"></a>console producer with output info</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bin/kafka-verifiable-producer.sh --topic test --max-messages 200000 --broker-list localhost:9092</div></pre></td></tr></table></figure>\n","categories":["study"],"tags":["学习","后端","中间件","大数据","kafka"]},{"title":"选择","url":"http://anson666.top/2017/07/10/choice/","content":"<blockquote>\n<p>漫漫人生路，有无数的选择，但紧要处只有几步。不同的选择，可能会决定我们不同的人生道路。  </p>\n</blockquote>\n<p>不知道从什么时候开始，选择对我的意义越来越重要。<br>现在的每一步都对以后的路有举足轻重的作用，自己的人生越来越输不起。<br>关于选择，可能由于工作的事情，最近有很大的感悟。</p>\n<h2 id=\"选择？\"><a href=\"#选择？\" class=\"headerlink\" title=\"选择？\"></a>选择？</h2><p>在MGJ的这段时间，可能是近几年来最安逸的时间。<br>安逸换来的确是当面临跳槽的时候，发现自己的工龄与社会认可的能力不在那么匹配。<br>在经历过各种刺激、打击、血虐过后，终于有人收留了！<br>去or不去 在好久没经历过选择的人来说变得无比纠结。<br>于是厚着脸皮请教了亲人、同事、朋友</p>\n<h2 id=\"选择！\"><a href=\"#选择！\" class=\"headerlink\" title=\"选择！\"></a>选择！</h2><h4 id=\"被选择的对象是否符合你的基本要求\"><a href=\"#被选择的对象是否符合你的基本要求\" class=\"headerlink\" title=\"被选择的对象是否符合你的基本要求\"></a>被选择的对象是否符合你的基本要求</h4><p>毫无疑问，这是最基本的条件，如果将要选择的对象还没有当前的好，那就不用纠结，不要为了选择而选择，果断的pass</p>\n<h4 id=\"被选择的对象带来的后果，是否和自己性格相匹配\"><a href=\"#被选择的对象带来的后果，是否和自己性格相匹配\" class=\"headerlink\" title=\"被选择的对象带来的后果，是否和自己性格相匹配\"></a>被选择的对象带来的后果，是否和自己性格相匹配</h4><p>过去有过选择，当时为了回家乡发展，选择了一家国企。没想到自己年轻气盛，血气方刚遇到安逸，慢节奏的国企时，完全的水土不服。<br>整天度日如年，就在自己满腔热血越燃越烈的时候，毅然选择改变当前的环境。后来这段经历成为一段“美好”的回忆。<br>当我们在选择的时候，需要对自己有一个全面的认识，选择适合自己的路，一定要忽略环境、收入这些可提高的影响。</p>\n<h4 id=\"被选择的对象是否利于自己当前的职业发展\"><a href=\"#被选择的对象是否利于自己当前的职业发展\" class=\"headerlink\" title=\"被选择的对象是否利于自己当前的职业发展\"></a>被选择的对象是否利于自己当前的职业发展</h4><p>在面试的过程中，很多公司都会详细的找你了解一下自己的职业规划，并作为是否录用的一个参考。<br>个人觉得这个十分有必要，求职本来就是一个双方相互选择的过程。你通过各种途径了解公司，然后觉得不错投递自己的简历。<br>公司根据你简历的知识技能及经历作为初选，然后双方面试相互了解，看对方是否适合自己今后的发展。然后选择是否向对方伸出橄榄枝。<br>但是在这个功利的社会，好多人忽略了自身今后的发展，而只选择了薪水导向。个人觉得这是一种对自己及其不负责任的选择！<br>平台？title？薪资？技术方向？工作地点？这几个方面都是换工作过程中常见的考虑点。可以根据当下的实际情况进行选择。</p>\n<h2 id=\"选择。\"><a href=\"#选择。\" class=\"headerlink\" title=\"选择。\"></a>选择。</h2><blockquote>\n<p>路漫漫其修远兮<br>人生，就处在选择、选择、再选择过程中<br>也许我们为自己的选择而感到满意，因为时间证明它是对的<br>也许我们为自己的选择很懊恼，因为结果不我们所期望的<br>但是无论我们选择的结果如何，我们都要去面对与接受它   </p>\n</blockquote>\n<p>每个选择都不是终点，而是迎接新的挑战的起点！</p>\n","categories":["life"],"tags":["生活","总结"]},{"title":"HashMap解析","url":"http://anson666.top/2017/06/28/hash-map-analyze/","content":"<h3 id=\"HashMap数据结构分析\"><a href=\"#HashMap数据结构分析\" class=\"headerlink\" title=\"HashMap数据结构分析\"></a>HashMap数据结构分析</h3><p>进入HashMap的Class能看到如下部分（为什么length必须是2的倍数呢?)    </p>\n<pre><code class=\"java\"><span class=\"comment\">/**\n * An empty table instance to share when the table is not inflated.\n */</span>\n<span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = {};\n.  .  .\n\n\n<span class=\"comment\">/**\n * The table, resized as necessary. Length MUST Always be a power of two.\n */</span>\n<span class=\"keyword\">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;\n.  .  .\n\n\n<span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>{\n    <span class=\"keyword\">final</span> K key;\n    V value;\n    Entry&lt;K,V&gt; next;\n    <span class=\"keyword\">int</span> hash;\n    .  .  .\n}\n</code></pre>\n<p>由此我们可以看出HashMap由一个table数组组成，这个table数组中包含有Key，Value，Next的一个Entry。<br>再次抽象一下：<br>HashTable总体由一个数组组成。而这些数组的每一个元素又是一个单向链表。<br>于是当我们put数据时，程序根据HashCode索引到具体的数组位置，得到一个Entry 链表，然后放入链表的首位。同理查询、删除也是如此。    </p>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>{\n       <span class=\"keyword\">if</span> (table == EMPTY_TABLE) {\n           inflateTable(threshold);\n       }\n       <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)   <span class=\"comment\">//HashMap与HashTable的区别点之一</span>\n           <span class=\"keyword\">return</span> putForNullKey(value);\n       <span class=\"keyword\">int</span> hash = hash(key);\n       <span class=\"keyword\">int</span> i = indexFor(hash, table.length);<span class=\"comment\">//计算出对应的数组索引位置</span>\n       <span class=\"comment\">//遍历对比链表中的值</span>\n       <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) {\n           Object k;\n           <span class=\"comment\">//如果key相同 则替换旧值</span>\n           <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {\n               V oldValue = e.value;\n               e.value = value;\n               e.recordAccess(<span class=\"keyword\">this</span>);\n               <span class=\"keyword\">return</span> oldValue;\n           }\n       }\n       <span class=\"comment\">//key不存在 则直接添加至链表队尾</span>\n       modCount++;<span class=\"comment\">//修正hashMap容量</span>\n       addEntry(hash, key, value, i);\n       <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;\n   }\n</code></pre>\n<h3 id=\"Hash索引\"><a href=\"#Hash索引\" class=\"headerlink\" title=\"Hash索引\"></a>Hash索引</h3><p>  大家注意看HashMap的put代码，出现了<code>int i = indexFor(hash, table.length);</code>而之后，利用返回结果取出了table中对应的Entry。<br>由此我们可知，该方法是根据HashCode的值计算对应的数组中的值。    </p>\n<pre><code class=\"java\"><span class=\"comment\">/**\n * Returns index for hash code h.\n */</span>\n<span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>{\n    <span class=\"comment\">// assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\";</span>\n    <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);\n}\n</code></pre>\n<p>  方法中，传入的HashCode与table的长度有一个按位与的操作，从而计算出table数组中的索引。前面已经提到，操作HashMap中的元素时先获取位置<br>然后遍历链表，执行相应的操作。遍历链表此时显得尤为的耗时。所以，为了保证HashMap的高效，要求每个键上的链表长度尽可能的小即为1。<a href=\"http://stackoverflow.com/questions/22935616/why-hash-method-in-hashmap\" target=\"_blank\" rel=\"external\">table长度为2时重复概率最小、且空间浪费最少</a>。我们再来看看构造函数。。。发现HashMap初始化时均需要指定table的长度，未指定的则默认为16。大家会发现HashMap初始化的时候，还有一<code>loadFactor</code>的参数<br>该参数的默认值为0.75f。这个参数有什么用呢？</p>\n<h3 id=\"HashMap的长度调整\"><a href=\"#HashMap的长度调整\" class=\"headerlink\" title=\"HashMap的长度调整\"></a>HashMap的长度调整</h3><p>随着HashMap存储数据的增多，由于table[]的定长，索引重复率提高。所以为了提高执行效率，此时需要扩容！<br>扩容需要重新数组长度，然后再将现在的数据重新分配进新的数组。想想就知道此时的效率是多么的低下，由此初始化一个合理的长度是多么的重要！<br>那么什么时候进行扩容操作呢？这时候就要用到上面提到的那个参数了。<br>扩容及计算新HashMap的扩容阀值    </p>\n<pre><code class=\"java\"><span class=\"comment\">/**\n * Inflates the table.\n */</span>\n<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">inflateTable</span><span class=\"params\">(<span class=\"keyword\">int</span> toSize)</span> </span>{\n    <span class=\"comment\">// Find a power of 2 &gt;= toSize</span>\n    <span class=\"keyword\">int</span> capacity = roundUpToPowerOf2(toSize);\n\n    threshold = (<span class=\"keyword\">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class=\"number\">1</span>);\n    table = <span class=\"keyword\">new</span> Entry[capacity];\n    initHashSeedAsNeeded(capacity);\n}\n</code></pre>\n<p>当HashMap的size大于threhold时及对HashMap进行扩容操作（代码见<em>public void putAll(Map&lt;? extends K, ? extends V&gt; m)</em><br>及<em>void addEntry(int hash, K key, V value, int bucketIndex)</em>）。threhold的最大值为2^30+1<br>那么扩容后的old value是怎么处理的呢？  </p>\n<pre><code class=\"java\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Entry[] newTable, <span class=\"keyword\">boolean</span> rehash)</span> </span>{\n    <span class=\"keyword\">int</span> newCapacity = newTable.length;\n    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e : table) {\n        <span class=\"comment\">//遍历所有的旧元素</span>\n        <span class=\"keyword\">while</span>(<span class=\"keyword\">null</span> != e) {\n            Entry&lt;K,V&gt; next = e.next;\n            <span class=\"comment\">//是否需要重新计算hash值</span>\n            <span class=\"keyword\">if</span> (rehash) {\n                e.hash = <span class=\"keyword\">null</span> == e.key ? <span class=\"number\">0</span> : hash(e.key);\n            }\n            <span class=\"comment\">//获取新的索引</span>\n            <span class=\"keyword\">int</span> i = indexFor(e.hash, newCapacity);\n            e.next = newTable[i];\n            newTable[i] = e;\n            e = next;\n        }\n    }\n}\n</code></pre>\n<p>由以上代码我们可以看出，在HashMap扩容过后，会依次遍历旧元素，重新计算索引位置，这样的操作是相当费时的。所以在执行HashMap初始化时，如果存储容量已知，我们可以指定<br>存储容量，防止HashMap扩容。  </p>\n<h3 id=\"HashMap与LinkedHashMap-TreeMap的区别\"><a href=\"#HashMap与LinkedHashMap-TreeMap的区别\" class=\"headerlink\" title=\"HashMap与LinkedHashMap,TreeMap的区别\"></a><a href=\"http://www.geeksforgeeks.org/differences-treemap-hashmap-linkedhashmap-java/\" target=\"_blank\" rel=\"external\">HashMap与LinkedHashMap,TreeMap的区别</a></h3><p> LinkedHashMap是HashMap子类，保存了记录的插入顺序，<br> 在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.<br> 也可以在构造时用带参数，按照应用次数排序。相对于HashMap中的Entry LinkedHashMap中多了header和after构成链表记录插入顺序  </p>\n<p> TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，<br> 当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap中的key要求存储对像实现了Comparable接口即是可比较的</p>\n","categories":["summarize"],"tags":["java","HashMap"]},{"title":"java concurrent解析","url":"http://anson666.top/2017/06/07/java-concurrent/","content":"<p><strong><em>Executor</em></strong> :抽象的Runnable任务的执行者，提供一个excute方法<br><strong><em>ExecutorService</em></strong> :抽象的线程池管理者，包含三种状态：运行、关闭、终止。当调用了shutdown()方法时，便进入了关闭状态，ExcecutorService<br>不在接受新的任务，当已经提交的任务完成后便达到终止状态。<br><strong><em>ReentrantLock</em></strong> :一个可重入得Lock代码层面的并发锁，需手动释放<br><strong><em>Future</em></strong> :一个Callable线程执行结束后返回的结果，提供isDone检查call方法是否执行完毕，cancel终止线程<br><strong><em>BlockingQueue</em></strong> :阻塞队列，常见ArrayBlockQueue,LinkedBlockQueue<br><strong><em>CompletionService</em></strong> :ExecutorService的扩展，可以获得线程执行结果的<br><strong><em>CountDownLatch</em></strong> :一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待<br><strong><em>CyclicBarrier</em></strong> :一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点<br><strong><em>ScheduledExecutorService</em></strong> :一个 ExecutorService，可安排在给定的延迟后运行或定期执行的命令<br><strong><em>Semaphore</em></strong> :一个计数信号量<br><strong><em>Executors</em></strong> :提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口</p>\n<h4 id=\"Executors中几种方法的对比\"><a href=\"#Executors中几种方法的对比\" class=\"headerlink\" title=\"Executors中几种方法的对比\"></a>Executors中几种方法的对比</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">方法名称</th>\n<th style=\"text-align:left\">缓存队列</th>\n<th style=\"text-align:left\">方法解析</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">newCachedThreadPool()</td>\n<td style=\"text-align:left\">SynchronousQueue</td>\n<td style=\"text-align:left\">1.缓存型池子，先查看池中有没有以前建立的线程，如果有，就 reuse.如果没有，就建一个新的线程加入池中  2.缓存型池子通常用于执行一些生存期很短的异步型任务因此在一些面向连接的daemon型SERVER中用得不多。但对于生存期短的异步任务，它是Executor的首选。3.能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s,超过这个IDLE时长，线程实例将被终止及移出池。注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">newFixedThreadPool(int)</td>\n<td style=\"text-align:left\">LinkedBlockingQueue</td>\n<td style=\"text-align:left\">1.newFixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程 2.其独特之处:任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子 3.和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的），所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器 4.从方法的源代码看，cache池和fixed 池调用的是同一个底层 池，只不过参数不同:fixed池线程数固定，并且是0秒IDLE（无IDLE）cache池线程数支持0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力），60秒IDLE</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">newScheduledThreadPool(int)</td>\n<td style=\"text-align:left\">DelayedWorkQueue</td>\n<td style=\"text-align:left\">1.调度型线程池 2.这个池子里的线程可以按schedule依次delay执行，或周期执行</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">newSingleThreadPool()</td>\n<td style=\"text-align:left\">LinkedBlockingQueue</td>\n<td style=\"text-align:left\">1.单例线程，任意时间池中只能有一个线程 2.用的是和cache池和fixed池相同的底层池，但线程数目是1-1,0秒IDLE（无IDLE）</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"BlockingQueue几种实现类\"><a href=\"#BlockingQueue几种实现类\" class=\"headerlink\" title=\"BlockingQueue几种实现类\"></a><a href=\"http://www.infoq.com/cn/articles/java-blocking-queue\" target=\"_blank\" rel=\"external\">BlockingQueue几种实现类</a></h4><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类名称</th>\n<th style=\"text-align:left\">功能描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">ArrayBlockingQueue</td>\n<td style=\"text-align:left\">由数组结构组成的有界阻塞队列,其构造函数必须带一个int参数来指明其大小.其所含的对象是以FIFO(先入先出)顺序排序的</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedBlockingQueue</td>\n<td style=\"text-align:left\">一个由链表结构组成的有界阻塞队列，如果没指定队列大小，则默认为Integer.Max,遵从FIFO</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">PriorityBlockingQueue</td>\n<td style=\"text-align:left\">一个支持优先级排序的无界阻塞队列,PriorityBlockingQueue是对PriorityQueue的再次包装，是基于堆数据结构的，而PriorityQueue是没有容量限制的,可能会导致 OutOfMemoryError,往入该队列中的元素要具有比较能力</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DelayQueue</td>\n<td style=\"text-align:left\">一个使用优先级队列实现的存放Delayed 元素的无界阻塞队列,只有在延迟期满时才能从中提取元素。该队列的头部是延迟期满后保存时间最长的 Delayed 元素</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">SynchronousQueue</td>\n<td style=\"text-align:left\">不存储元素，特殊的阻塞队列,对其的操作必须是放和取交替完成的</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedBlockingQueue</td>\n<td style=\"text-align:left\">一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法.transfer方法。如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">LinkedBlockingDeque</td>\n<td style=\"text-align:left\">是一个由链表结构组成的双向阻塞队列,所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast等方法</td>\n</tr>\n</tbody>\n</table>\n<p><strong><em>BlockingQueue的常用方法</em></strong>：</p>\n<blockquote>\n<p>add        增加一个元索                     如果队列已满，则抛出一个IIIegaISlabEepeplian异常<br>remove   移除并返回队列头部的元素    如果队列为空，则抛出一个NoSuchElementException异常<br>element  返回队列头部的元素             如果队列为空，则抛出一个NoSuchElementException异常<br>offer       添加一个元素并返回true       如果队列已满，则返回false<br>poll(time)         移除并返问队列头部的元素    如果队列为空，则返回null<br>peek       返回队列头部的元素             如果队列为空，则返回null<br>put         添加一个元素                      如果队列满，则阻塞<br>take        移除并返回队列头部的元素     如果队列为空，则阻塞</p>\n</blockquote>\n","categories":["summarize"],"tags":["java","concurrent","多线程","Executor"]},{"title":"小米面试总结","url":"http://anson666.top/2017/05/28/xiaomi-interview/","content":"<p>上周面了一下小米的金融，不管结果如何，觉得还是有必要对其中涉及到知识点及问题进行总结。</p>\n<h3 id=\"Object类中的方法\"><a href=\"#Object类中的方法\" class=\"headerlink\" title=\"Object类中的方法\"></a>Object类中的方法</h3><ul>\n<li><p>+equals():Boolean<br>原生的equals比较的是两个对象的引用是否相同，换而言之就是比较对象的内存地址是否一致</p>\n</li>\n<li><p>+hashcode():int<br>通过散列算法计算对象的hash值<br>拓展：解决hash冲突的方式有哪些？</p>\n</li>\n<li><p>+toString():String<br>返回对象的字符串表示方式</p>\n</li>\n<li><p>+wait()/wait(long time)/wait(long time,int nanos):void<br>使当前线程让出CPU资源进入等待状态，<br>当其他线程调用该对象的notify/notifyAll方法时跳出等待状态</p>\n</li>\n<li><p>+notify():void<br>唤醒监听这个对象的一个线程</p>\n</li>\n<li><p>+notifyAll():void<br>唤醒监听这个对象的所有线程</p>\n</li>\n<li><p>+getClass():Class<br>返回当前对象的runtime class</p>\n</li>\n<li><p>clone:Object<br>返回当前对象的副本，使浅克隆。深克隆的话可以用序列化及反序列化方式</p>\n</li>\n<li><p>finalize:void<br>当对象将被垃圾收集器回收的时候，阻止垃圾回收器回收，该方法只能使对象存活一次 </p>\n</li>\n</ul>\n<h3 id=\"保证线程安全的方式有哪些以及他们之间的区别？\"><a href=\"#保证线程安全的方式有哪些以及他们之间的区别？\" class=\"headerlink\" title=\"保证线程安全的方式有哪些以及他们之间的区别？\"></a>保证线程安全的方式有哪些以及他们之间的区别？</h3><p> 目前保证线程安全的三种方式<br>    1.用volatile修饰的变量<br>    2.用Reetrantlock 即lock和unlock修饰的代码块<br>    3.用synchronized修饰的方法或者代码块<br> volatile:<br>    使用该关键字修饰的，访问变量时告诉jvm需要从主内存中获取，保证可见性，不会造成线程阻塞；<br> synchronized:<br>    是jvm级的安全锁，保证可见性及原子性，使用时如果发生中断异常会主动释放当前锁，会造成线程阻塞；<br> Reetrantlock:<br>    代码级安全锁，保证可见性及原子性，使用时不会主动释放当前锁，需要手动释放，会造成线程阻塞</p>\n<p> 1）用法区别<br>     synchronized(隐式锁)：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。<br>     lock（显示锁）：需要显示指定起始位置和终止位置。一般使用ReentrantLock类做为锁，多个线程中必须要使用一个ReentrantLock类做为对 象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。<br> 2）synchronized和lock性能区别<br>     synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。<br>     synchronized采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其 他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。<br>     Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就 是CAS操作（Compare and Swap）。<br> 3）synchronized和lock用途区别<br>     synchronized原语和ReentrantLock在一般情况下没有什么区别，但是在非常复杂的同步应用中，请考虑使用ReentrantLock，特别是遇到下面2种需求的时候。<br>     1.某个线程在等待一个锁的控制权的这段时间需要中断<br>     2.需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程<br>     3.具有公平锁功能，每个到来的线程都将排队等候、</p>\n<h3 id=\"写一个生产消费模型\"><a href=\"#写一个生产消费模型\" class=\"headerlink\" title=\"写一个生产消费模型\"></a>写一个生产消费模型</h3><h3 id=\"二分查找递归及非递归写法\"><a href=\"#二分查找递归及非递归写法\" class=\"headerlink\" title=\"二分查找递归及非递归写法\"></a>二分查找递归及非递归写法</h3><h3 id=\"用两个stack模拟一个queue\"><a href=\"#用两个stack模拟一个queue\" class=\"headerlink\" title=\"用两个stack模拟一个queue\"></a>用两个stack模拟一个queue</h3><h3 id=\"简单的谈谈jvm\"><a href=\"#简单的谈谈jvm\" class=\"headerlink\" title=\"简单的谈谈jvm\"></a>简单的谈谈jvm</h3><h3 id=\"项目中遇到的难点及解决方式\"><a href=\"#项目中遇到的难点及解决方式\" class=\"headerlink\" title=\"项目中遇到的难点及解决方式\"></a>项目中遇到的难点及解决方式</h3><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p> 整个面试的过程中，发现对基础的知识的提问相对于自己参与项目的提问整体时间所占比例大幅下降<br> 由于更加专业化，面试官在提问的过程中也着重于他们自己的业务。所以整体感觉，<br> 如果他们问的不是你自己感兴趣或者职业侧重点，不管是不是当前阶段的知识盲区，<br> 最后能不能拿到offer都可以在某种程度上作为自己选择接不接offer的一个参考点。</p>\n","categories":["summarize"],"tags":["总结","工作","面试"]},{"title":"大连之行","url":"http://anson666.top/2017/05/22/daling-travelling/","content":"<p>趁着好基友毕业前夕，去大连浪了一波。<br>大连这座城市，在我之前的印象中就是薄xl和万达的发家地。然后就传说中的绿化很好，很赞！<br>抵达大连已经早上八点多了，<br>一出火车站给人的感觉十分的清爽。感觉整洁的街道<br>一路绿树掩映，路边偶尔的鲜花点缀，丝毫没有已到五月中旬的感觉。</p>\n<p>在好基友的导游下，第一站我们来到了星海广场<br>听说之前广场中央的华表由于bo的倒台而拆除了<br>另外大连建市一百年的金色脚印也被铲除<br>除了这个之外 周围的一切都看起来这么的祥和<br><img src=\"http://s11.mogucdn.com/mlcdn/c45406/170526_53g3l98j5d4dfaie3al8k446a42el_12168x3824.jpg_500x9999.v1c7E.jpg\" alt=\"星海广场\"></p>\n<p>一群海鸥在熙攘的人群头上盘旋，远处的大桥看起来是如此的刺眼。<br>大好的海景视野就这么给拦腰斩断了。  </p>\n<p>恰逢大连举办第十七届国际徒步节，于是跟随大部队。<br>我们也开始了30多公里的沿海滨路徒步而整个大连的景色都集中在这条路上  </p>\n<p>滨海路沿线风景<br><img src=\"http://s2.mogucdn.com/mlcdn/c45406/170526_33hi3hce87922fadfi7f9e0kf6304_1280x960.jpg_500x9999.v1c7E.jpg\" alt=\"滨海西路\"></p>\n<p>退役的辽宁舰<br><img src=\"http://s11.mogucdn.com/mlcdn/c45406/170526_0d6073k5119acjhhjib7cg9091bag_1280x960.jpg_500x9999.v1c7E.jpg\" alt=\"辽宁舰\"></p>\n<p>抓拍的海鸥<br><img src=\"http://s11.mogucdn.com/mlcdn/c45406/170526_3kf14k5hbd50fe1l8gge71e6d22cd_1280x960.jpg_500x9999.v1c7E.jpg\" alt=\"海鸥\"></p>\n<p>海边的小鹅暖石<br><img src=\"http://s11.mogucdn.com/mlcdn/c45406/170526_7dfj89j6lk92aig0aj93g5dc256ea_1280x960.jpg_500x9999.v1c7E.jpg\" alt=\"鹅暖石\"></p>\n<p>我们就这样一步一步，边走边逗留，从九点10分左右出发，一直走到了下午的5点半。沿着滨海西路、滨海中路，最后终于到了滨海东路。<br>基友的脚也起泡了，实在是太累了。于是我们就此作罢，开始往回走。  </p>\n<p>最后夜宿星海广场，晚上也没什么活动，倒头就睡着了</p>\n<p>第二天我们启程前往造船厂，远观了正在建造中的中国第一艘国产航母<br><img src=\"http://s2.mogucdn.com/mlcdn/c45406/170526_5g4815b8e161fg1ja14lg8h0g140c_1280x960.jpg_500x9999.v1c7E.jpg\" alt=\"国产航母\"></p>\n<p>就此两天的大连之行就基本结束了。</p>\n","categories":["life"],"tags":["生活","旅行"]},{"title":"java后端学习知识点梳理","url":"http://anson666.top/2017/05/18/java-road-map/","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>  经过几年的工作学习，对后端开发有了一定的认识。下面对工作中遇到的部分知识点进行终结梳理。<br>  一个是今后对照参考一下作为学习提纲，再者进行简单总结进行复习回顾。</p>\n<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><h3 id=\"网络知识\"><a href=\"#网络知识\" class=\"headerlink\" title=\"网络知识\"></a>网络知识</h3><ul>\n<li>HTTP协议</li>\n<li>OSI七层模型</li>\n<li>TCP/IP协议</li>\n<li>网络通信</li>\n</ul>\n<h3 id=\"分布式相关\"><a href=\"#分布式相关\" class=\"headerlink\" title=\"分布式相关\"></a>分布式相关</h3><ul>\n<li>负载均衡（七层，四层，系统。。。）</li>\n<li>SOAP</li>\n<li>分库分表</li>\n<li>分布式事务</li>\n</ul>\n<h3 id=\"开源框架\"><a href=\"#开源框架\" class=\"headerlink\" title=\"开源框架\"></a>开源框架</h3><ul>\n<li>SpringMVC</li>\n<li>Struts2</li>\n<li>Mybatis</li>\n<li>Hibernate</li>\n<li>SpringBoot</li>\n<li>Dubbo</li>\n<li>Shiro</li>\n</ul>\n<h3 id=\"数据库及中间件\"><a href=\"#数据库及中间件\" class=\"headerlink\" title=\"数据库及中间件\"></a>数据库及中间件</h3><h4 id=\"关系型数据库\"><a href=\"#关系型数据库\" class=\"headerlink\" title=\"关系型数据库\"></a>关系型数据库</h4><ul>\n<li>Mysql</li>\n<li>PostgreSql</li>\n<li>Oracle</li>\n</ul>\n<h4 id=\"kv\"><a href=\"#kv\" class=\"headerlink\" title=\"kv\"></a>kv</h4><ul>\n<li>redis</li>\n<li>memcache</li>\n<li>mongodb</li>\n</ul>\n<h4 id=\"搜索引擎\"><a href=\"#搜索引擎\" class=\"headerlink\" title=\"搜索引擎\"></a>搜索引擎</h4><ul>\n<li>solr</li>\n<li>elastic search</li>\n<li>lucence</li>\n</ul>\n<h4 id=\"MQ\"><a href=\"#MQ\" class=\"headerlink\" title=\"MQ\"></a>MQ</h4><ul>\n<li>kafka</li>\n<li>RabitMQ</li>\n</ul>\n<h4 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h4><ul>\n<li>Nginx</li>\n<li>LVS</li>\n</ul>\n<h4 id=\"web容器\"><a href=\"#web容器\" class=\"headerlink\" title=\"web容器\"></a>web容器</h4><ul>\n<li>Tomcat</li>\n<li>jetty</li>\n</ul>\n<h4 id=\"其他知识点\"><a href=\"#其他知识点\" class=\"headerlink\" title=\"其他知识点\"></a>其他知识点</h4><ul>\n<li>JVM</li>\n<li>多线程</li>\n<li>IO</li>\n<li>设计模式</li>\n<li>网络安全</li>\n<li>大数据相关</li>\n<li>基本算法</li>\n</ul>\n","categories":["study"],"tags":["学习","java","后端","中间件","数据库"]},{"title":"The beginning or the end","url":"http://anson666.top/2017/05/17/foreword/","content":"<h2 id=\"The-end\"><a href=\"#The-end\" class=\"headerlink\" title=\"The end\"></a>The end</h2><p>  不知不觉2017年快过半了。不得不感慨一下时光的荏苒。回顾这半年还是可圈可点的，只是真正到总结的时候却变得那么不值一提。<br>  一次“偶然”的机会，四月底，踏上了换工作的路程。写简历的时候，颇有踌躇，在公司的一年余竟然总结不出什么可圈可点的地方。<br>  看着简历上一两笔概况的一年半。。。<br>  看着一份份简历出去后石沉大海。。。<br>  看着全白的github提交记录。。。<br>  看着当时创建的技术blog再无更新。。。</p>\n<p>  我这个毕业快三年的七尺男儿，感觉到了前所未有的危机。  </p>\n<p>  鬼知道这段时间干了什么<br>  鬼知道这段时间学了什么<br>  鬼知道这段时间经历了什么<br>  鬼知道接下来的路该怎么走</p>\n<p>  绝望！伤心！失落！<br>  生活上的丰衣足食的环境里让我失去了向上攀爬的动力！<br>  工作上的得心应手让我失去了继续学习的能力！</p>\n<p>  我！当危机来临时变得这么手足无措。</p>\n<h2 id=\"The-beginning\"><a href=\"#The-beginning\" class=\"headerlink\" title=\"The beginning\"></a>The beginning</h2><p>  决定从现在起一定要改变现状<br>  工作上开始记录总结<br>  生活上乐于分享<br>  学习上做好笔记</p>\n<p>  不图别的至少让下次换工作的时候简历及知识点上有亮点和快速复习！！！</p>\n<p>  路漫漫其修远兮，我将上下而求索！</p>\n","categories":["life"],"tags":["生活","工作","学习"]},{"title":"about","url":"http://anson666.top/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://anson666.top/category/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://anson666.top/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://anson666.top/tag/index.html","content":"","categories":[],"tags":[]}]